const db = require('../config/database');
const db = require('../config/database');
const { validationResult } = require('express-validator');
const fs = require('fs');
const path = require('path');

// Get all cars with optional filters
exports.getAllCars = async (req, res) => {
  try {
    // Extract filters from query parameters
    const {
      location,
      start_date,
      end_date,
      min_price,
      max_price,
      min_year,
      max_year,
      car_type,
      features,
      colors
    } = req.query;

    // Build WHERE clauses based on filters
    let whereClause = [];
    let values = [];
    let valueIndex = 1;

    // Location filter
    if (location) {
      whereClause.push(`LOWER(location) LIKE LOWER($${valueIndex})`);
      values.push(`%${location}%`);
      valueIndex++;
    }

    // Date range filter for availability
    if (start_date && end_date) {
      whereClause.push(`availability_start <= $${valueIndex} AND availability_end >= $${valueIndex + 1}`);
      values.push(end_date, start_date); // Swap dates for availability check
      valueIndex += 2;
    }

    // Price range filter
    if (min_price) {
      whereClause.push(`price_per_day >= $${valueIndex}`);
      values.push(min_price);
      valueIndex++;
    }
    if (max_price) {
      whereClause.push(`price_per_day <= $${valueIndex}`);
      values.push(max_price);
      valueIndex++;
    }

    // Year range filter
    if (min_year) {
      whereClause.push(`year >= $${valueIndex}`);
      values.push(min_year);
      valueIndex++;
    }
    if (max_year) {
      whereClause.push(`year <= $${valueIndex}`);
      values.push(max_year);
      valueIndex++;
    }

    // Car type filter
    if (car_type && car_type !== 'all') {
      whereClause.push(`car_type = $${valueIndex}`);
      values.push(car_type);
      valueIndex++;
    }

    // Features filter (JSON array)
    if (features) {
      try {
        const featuresArray = JSON.parse(features);
        if (Array.isArray(featuresArray) && featuresArray.length > 0) {
          let featureConditions = featuresArray.map((feature, index) => {
            values.push(feature);
            return `features @> ARRAY[$${valueIndex + index}]::text[]`;
          });
          whereClause.push(`(${featureConditions.join(' OR ')})`);
          valueIndex += featuresArray.length;
        }
      } catch (err) {
        console.error('Error parsing features filter:', err);
      }
    }

    // Colors filter (JSON array)
    if (colors) {
      try {
        const colorsArray = JSON.parse(colors);
        if (Array.isArray(colorsArray) && colorsArray.length > 0) {
          whereClause.push(`LOWER(color) IN (${colorsArray.map((_, index) => `LOWER($${valueIndex + index})`).join(', ')})`);
          colorsArray.forEach(color => values.push(color));
          valueIndex += colorsArray.length;
        }
      } catch (err) {
        console.error('Error parsing colors filter:', err);
      }
    }

    // Build query
    let query = `
      SELECT c.*, u.name as host_name, u.id as user_id
      FROM cars c
      JOIN users u ON c.user_id = u.id
      WHERE c.status = 'available'
    `;

    if (whereClause.length > 0) {
      query += ` AND ${whereClause.join(' AND ')}`;
    }

    // Add ordering
    query += ' ORDER BY c.created_at DESC';

    console.log('Car search query:', query);
    console.log('Query parameters:', values);

    const result = await db.query(query, values);
    console.log(`Found ${result.rows.length} cars`);

    // Check for date conflicts with existing bookings if date range was specified
    if (start_date && end_date) {
      // Get cars with booking conflicts
      const bookingConflictQuery = `
        SELECT DISTINCT b.car_id
        FROM bookings b
        WHERE b.status IN ('accepted', 'pending')
          AND (
            (b.start_date <= $1 AND b.end_date >= $2) -- Overlap check
          )
      `;

      const bookingConflicts = await db.query(bookingConflictQuery, [end_date, start_date]);
      
      // Create set of car IDs with conflicts
      const conflictCarIds = new Set(bookingConflicts.rows.map(row => row.car_id));
      
      // Filter out cars with booking conflicts
      const availableCars = result.rows.filter(car => !conflictCarIds.has(car.id));
      
      console.log(`Filtered out ${result.rows.length - availableCars.length} cars with booking conflicts`);
      
      res.json(availableCars);
    } else {
      // If no date filter, return all matching cars
      res.json(result.rows);
    }
  } catch (err) {
    console.error('Error fetching cars:', err);
    res.status(500).json({ message: 'Server error while fetching cars' });
  }
};

// Keep the rest of the file as is, just adding the missing function

// Get cars owned by the current user (host)
exports.getHostCars = async (req, res) => {
  try {
    const userId = req.user.id;

    const query = `
      SELECT c.*, 
             (SELECT COUNT(*) FROM bookings b WHERE b.car_id = c.id AND b.status = 'accepted') as active_bookings_count
      FROM cars c
      WHERE c.user_id = $1
      ORDER BY c.created_at DESC
    `;

    const result = await db.query(query, [userId]);
    
    console.log(`Found ${result.rows.length} cars for host ${userId}`);

    // Format image URLs
    const cars = result.rows.map(car => {
      if (car.image && !car.image.startsWith('http')) {
        const baseUrl = process.env.BASE_URL || 'http://localhost:5000';
        
        // Normalize the path
        let imagePath = car.image;
        if (!imagePath.startsWith('uploads/')) {
          imagePath = `uploads/cars/${imagePath}`;
        }
        
        car.image_url = `${baseUrl}/${imagePath}`;
      }
      return car;
    });

    res.json(cars);
  } catch (err) {
    console.error('Error fetching host cars:', err);
    res.status(500).json({ message: 'Server error while fetching cars' });
  }
};

// Check if a car has active bookings
exports.checkActiveBookings = async (req, res) => {
  try {
    const carId = req.params.id;
    const userId = req.user.id;

    // First check if the user owns this car
    const carCheck = await db.query('SELECT user_id FROM cars WHERE id = $1', [carId]);
    
    if (carCheck.rows.length === 0) {
      return res.status(404).json({ message: 'Car not found' });
    }

    if (carCheck.rows[0].user_id !== userId) {
      return res.status(403).json({ message: 'You can only check bookings for your own cars' });
    }

    // Check for active bookings
    const bookingsResult = await db.query(
      `SELECT COUNT(*) as count
       FROM bookings
       WHERE car_id = $1 AND status = 'accepted'`,
      [carId]
    );

    const activeBookings = parseInt(bookingsResult.rows[0].count) > 0;

    res.json({
      hasActiveBookings: activeBookings,
      activeBookingsCount: parseInt(bookingsResult.rows[0].count)
    });
  } catch (err) {
    console.error('Error checking active bookings:', err);
    res.status(500).json({ message: 'Server error while checking active bookings' });
  }
};

// Update car availability
exports.updateCarAvailability = async (req, res) => {
  try {
    const carId = req.params.id;
    const userId = req.user.id;
    const { availability_start, availability_end } = req.body;

    // Check if dates are valid
    if (new Date(availability_end) < new Date(availability_start)) {
      return res.status(400).json({ message: 'End date must be after start date' });
    }

    // Check if the user owns this car
    const carCheck = await db.query('SELECT user_id FROM cars WHERE id = $1', [carId]);
    
    if (carCheck.rows.length === 0) {
      return res.status(404).json({ message: 'Car not found' });
    }

    if (carCheck.rows[0].user_id !== userId) {
      return res.status(403).json({ message: 'You can only update your own cars' });
    }

    // Check for overlapping accepted bookings
    const bookingsResult = await db.query(
      `SELECT COUNT(*) as count
       FROM bookings
       WHERE car_id = $1 
         AND status = 'accepted' 
         AND (
           (start_date <= $3 AND end_date >= $2)
         )`,
      [carId, availability_start, availability_end]
    );

    if (parseInt(bookingsResult.rows[0].count) > 0) {
      return res.status(409).json({ 
        message: 'Cannot update availability as there are accepted bookings in this date range' 
      });
    }

    // Update availability
    const result = await db.query(
      `UPDATE cars
       SET availability_start = $1, 
           availability_end = $2,
           updated_at = NOW()
       WHERE id = $3 AND user_id = $4
       RETURNING *`,
      [availability_start, availability_end, carId, userId]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ message: 'Car not found or you do not have permission' });
    }

    res.json({
      message: 'Car availability updated successfully',
      car: result.rows[0]
    });
  } catch (err) {
    console.error('Error updating car availability:', err);
    res.status(500).json({ message: 'Server error while updating car availability' });
  }
};

// Delete a car
exports.deleteCar = async (req, res) => {
  try {
    const carId = req.params.id;
    const userId = req.user.id;

    // Check if the user owns this car
    const carCheck = await db.query('SELECT * FROM cars WHERE id = $1', [carId]);
    
    if (carCheck.rows.length === 0) {
      return res.status(404).json({ message: 'Car not found' });
    }

    if (carCheck.rows[0].user_id !== userId) {
      return res.status(403).json({ message: 'You can only delete your own cars' });
    }

    // Check for active bookings
    const bookingsResult = await db.query(
      `SELECT COUNT(*) as count
       FROM bookings
       WHERE car_id = $1 AND status = 'accepted'`,
      [carId]
    );

    if (parseInt(bookingsResult.rows[0].count) > 0) {
      return res.status(409).json({ 
        message: 'Cannot delete car as there are active bookings' 
      });
    }

    // Get car details for image deletion
    const car = carCheck.rows[0];
    
    // Delete car from database
    await db.query('DELETE FROM cars WHERE id = $1 AND user_id = $2', [carId, userId]);

    // Clean up image if it exists
    if (car.image) {
      const fs = require('fs');
      const path = require('path');
      
      try {
        // Normalize the path
        let imagePath = car.image;
        if (imagePath.startsWith('uploads/')) {
          imagePath = path.join(__dirname, '../../', imagePath);
        } else {
          imagePath = path.join(__dirname, '../../uploads/cars/', imagePath);
        }
        
        // Check if file exists before deletion
        if (fs.existsSync(imagePath)) {
          fs.unlinkSync(imagePath);
          console.log(`Deleted image file: ${imagePath}`);
        }
      } catch (fileErr) {
        console.error('Error deleting image file:', fileErr);
        // Continue with the response even if image deletion fails
      }
    }

    res.json({ 
      message: 'Car deleted successfully',
      success: true 
    });
  } catch (err) {
    console.error('Error deleting car:', err);
    res.status(500).json({ message: 'Server error while deleting car' });
  }
};

// Get car by ID
exports.getCarById = async (req, res) => {
  try {
    const carId = req.params.id;

    const query = `
      SELECT c.*, 
             u.name as host_name, 
             u.id as user_id,
             u.created_at as host_joined_date,
             (SELECT AVG(rating) FROM ratings WHERE car_id = c.id) as rating,
             (SELECT AVG(rating) FROM ratings WHERE rating_for = c.user_id) as host_rating
      FROM cars c
      JOIN users u ON c.user_id = u.id
      WHERE c.id = $1
    `;

    const result = await db.query(query, [carId]);

    if (result.rows.length === 0) {
      return res.status(404).json({ message: 'Car not found' });
    }

    // Format image URL
    const car = result.rows[0];
    if (car.image && !car.image.startsWith('http')) {
      const baseUrl = process.env.BASE_URL || 'http://localhost:5000';
      
      // Normalize the path
      let imagePath = car.image;
      if (!imagePath.startsWith('uploads/')) {
        imagePath = `uploads/cars/${imagePath}`;
      }
      
      car.image_url = `${baseUrl}/${imagePath}`;
    }

    res.json(car);
  } catch (err) {
    console.error('Error fetching car details:', err);
    res.status(500).json({ message: 'Server error while fetching car details' });
  }
};
// Get cars owned by the current user (host)
exports.getHostCars = async (req, res) => {
  try {
    const userId = req.user.id;

    console.log(`Fetching cars for host ${userId}`);

    const query = `
      SELECT c.*, 
             (SELECT COUNT(*) FROM bookings b WHERE b.car_id = c.id AND b.status = 'accepted') as active_bookings_count
      FROM cars c
      WHERE c.user_id = $1
      ORDER BY c.created_at DESC
    `;

    const result = await db.query(query, [userId]);
    
    console.log(`Found ${result.rows.length} cars for host ${userId}`);

    // Format image URLs
    const cars = result.rows.map(car => {
      if (car.image && !car.image_url) {
        const baseUrl = process.env.BASE_URL || 'http://localhost:5000';
        
        // Normalize the path
        let imagePath = car.image;
        if (!imagePath.startsWith('uploads/')) {
          imagePath = `uploads/cars/${imagePath}`;
        }
        
        car.image_url = `${baseUrl}/${imagePath}`;
      }
      return car;
    });

    res.json(cars);
  } catch (err) {
    console.error('Error fetching host cars:', err);
    res.status(500).json({ message: 'Server error while fetching cars' });
  }
};
// Get cars owned by the current user (host)
exports.getHostCars = async (req, res) => {
  try {
    const userId = req.user.id;
    console.log(`Fetching cars for host ${userId}`);
    
    const query = `
      SELECT c.*,
             (SELECT COUNT(*) FROM bookings b WHERE b.car_id = c.id AND b.status = 'accepted') as active_bookings_count 
      FROM cars c
      WHERE c.user_id = $1
      ORDER BY c.created_at DESC
    `;
    
    const result = await db.query(query, [userId]);
    
    console.log(`Found ${result.rows.length} cars for host ${userId}`);
    
    // Format image URLs
    const cars = result.rows.map(car => {
      if (car.image && !car.image_url) {
        const baseUrl = process.env.BASE_URL || 'http://localhost:5000';
        
        // Normalize the path
        let imagePath = car.image;
        if (!imagePath.startsWith('uploads/')) {
          imagePath = `uploads/cars/${imagePath}`;
        }
        
        car.image_url = `${baseUrl}/${imagePath}`;
      }
      return car;
    });

    res.json(cars);
  } catch (err) {
    console.error('Error fetching host cars:', err);
    res.status(500).json({ message: 'Server error while fetching cars' });
  }
};
// Get cars owned by the current user (host)
exports.getHostCars = async (req, res) => {
  try {
    const userId = req.user.id;
    console.log(`Fetching cars for host ${userId}`);
    
    const query = `
      SELECT c.*,
             (SELECT COUNT(*) FROM bookings b WHERE b.car_id = c.id AND b.status = 'accepted') as active_bookings_count 
      FROM cars c
      WHERE c.user_id = $1
      ORDER BY c.created_at DESC
    `;
    
    const result = await db.query(query, [userId]);
    
    console.log(`Found ${result.rows.length} cars for host ${userId}`);
    
    // Format image URLs
    const cars = result.rows.map(car => {
      if (car.image && !car.image_url) {
        const baseUrl = process.env.BASE_URL || 'http://localhost:5000';
        
        // Normalize the path
        let imagePath = car.image;
        if (!imagePath.startsWith('uploads/')) {
          imagePath = `uploads/cars/${imagePath}`;
        }
        
        car.image_url = `${baseUrl}/${imagePath}`;
      }
      return car;
    });

    res.json(cars);
  } catch (err) {
    console.error('Error fetching host cars:', err);
    res.status(500).json({ message: 'Server error while fetching cars' });
  }
};
