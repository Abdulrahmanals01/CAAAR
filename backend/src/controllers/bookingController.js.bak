const db = require('../config/database');

// Create a new booking
exports.createBooking = async (req, res) => {
  try {
    const { car_id, start_date, end_date } = req.body;
    const renter_id = req.user.id;

    // Check basic validation
    if (!car_id || !start_date || !end_date) {
      return res.status(400).json({ message: 'Missing required fields' });
    }

    // Calculate total price based on number of days and car price
    const carInfo = await db.query('SELECT price_per_day FROM cars WHERE id = $1', [car_id]);
    if (carInfo.rows.length === 0) {
      return res.status(404).json({ message: 'Car not found' });
    }

    const pricePerDay = carInfo.rows[0].price_per_day;
    const days = Math.ceil((new Date(end_date) - new Date(start_date)) / (1000 * 60 * 60 * 24)) + 1;
    const totalPrice = days * pricePerDay;

    // Create booking
    const booking = await db.query(
      `INSERT INTO bookings (renter_id, car_id, start_date, end_date, total_price, status)
       VALUES ($1, $2, $3, $4, $5, 'pending')
       RETURNING *`,
      [renter_id, car_id, start_date, end_date, totalPrice]
    );

    res.status(201).json(booking.rows[0]);
  } catch (err) {
    console.error('Error creating booking:', err);
    res.status(500).json({ message: 'Server error while creating booking' });
  }
};

// Get user's bookings
exports.getUserBookings = async (req, res) => {
  try {
    const userId = req.user.id;
    const userRole = req.user.role;

    console.log(`Getting bookings for user ${userId} with role ${userRole}`);

    let query;
    let params;

    if (userRole === 'renter') {
      query = `
        SELECT b.*, c.brand, c.model, c.year, c.price_per_day, c.image,
          u.name as host_name
        FROM bookings b
        JOIN cars c ON b.car_id = c.id
        JOIN users u ON c.user_id = u.id
        WHERE b.renter_id = $1
        ORDER BY b.created_at DESC
      `;
      params = [userId];
    } else {
      query = `
        SELECT b.*, c.brand, c.model, c.year, c.price_per_day, c.image,
          u.name as renter_name
        FROM bookings b
        JOIN cars c ON b.car_id = c.id
        JOIN users u ON b.renter_id = u.id
        WHERE c.user_id = $1
        ORDER BY b.created_at DESC
      `;
      params = [userId];
    }

    const bookings = await db.query(query, params);
    console.log(`Found ${bookings.rows.length} bookings`);

    res.json(bookings.rows);
  } catch (err) {
    console.error('Error getting bookings:', err);
    res.status(500).json({ message: 'Server error while getting bookings' });
  }
};

// Update booking status (normal method)
exports.updateBookingStatus = async (req, res) => {
  try {
    const bookingId = req.params.id;
    const { status } = req.body;

    console.log(`Updating booking ${bookingId} to status: ${status}`);

    // Special handling for cancellation
    if (status === 'canceled') {
      return cancelBooking(req, res, bookingId);
    }

    // For other statuses, continue with normal update
    if (!['pending', 'accepted', 'rejected', 'completed'].includes(status)) {
      return res.status(400).json({ message: 'Invalid status' });
    }

    // Update booking
    const result = await db.query(
      'UPDATE bookings SET status = $1 WHERE id = $2 RETURNING *',
      [status, bookingId]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ message: 'Booking not found' });
    }

    console.log('Booking updated successfully:', result.rows[0]);
    res.json(result.rows[0]);
  } catch (err) {
    console.error('Error updating booking status:', err);
    res.status(500).json({ message: 'Server error while updating booking status' });
  }
};

// Special function to handle cancellation
async function cancelBooking(req, res, bookingId) {
  try {
    const userId = req.user.id;

    // First check if the booking exists and belongs to this user
    const bookingCheck = await db.query(
      'SELECT * FROM bookings WHERE id = $1',
      [bookingId]
    );

    if (bookingCheck.rows.length === 0) {
      return res.status(404).json({ message: 'Booking not found' });
    }

    const booking = bookingCheck.rows[0];

    // Check if the user is the renter who made this booking
    if (booking.renter_id !== userId) {
      return res.status(403).json({ message: 'You can only cancel your own bookings' });
    }

    // Get a client from the pool for transaction
    const client = await db.pool.connect();

    try {
      await client.query('BEGIN');

      // Direct update to bypass any triggers
      await client.query(
        'UPDATE bookings SET status = $1 WHERE id = $2',
        ['canceled', bookingId]
      );

      await client.query('COMMIT');

      // Get the updated booking
      const result = await client.query(
        'SELECT * FROM bookings WHERE id = $1',
        [bookingId]
      );

      console.log('Booking canceled successfully');
      return res.json(result.rows[0]);
    } catch (err) {
      await client.query('ROLLBACK');
      throw err;
    } finally {
      client.release();
    }
  } catch (err) {
    console.error('Error canceling booking:', err);
    return res.status(500).json({ message: 'Server error while canceling booking' });
  }
}
